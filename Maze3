import java.util.ArrayList;

import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

public class Maze3 {

	int[][] maze;
	int numberOfRooms;
	DisjointSet s;
	Random random;
	int length;
	
	public Maze3(int n) {
		maze = new int[n*n][4]; //[n][0] = north,[n][1] = south,[n][2] = east,[n][3] = west,
		length = n;
		for (int j = 0; j < n*n; j++) {
			for (int h = 0; h < 4; h++) {
				maze[j][h] = 1;  //initially all closed doors;
			}
		}
		numberOfRooms = (n*n);
		s = new DisjointSet(numberOfRooms);
		random = new Random();
		
		 int[] rooms = new int[numberOfRooms];
		 
		 for (int k = 0; k < numberOfRooms; k++) {
			 rooms[k] = k;
		 }
		 
		 int[] randomArray = shuffleArray(rooms);
		 
		 for (int i = 0; i < randomArray.length; i++) {
			 System.out.println(randomArray[i]);
			 System.out.println(s.getArray()[i]);
		 }
		 int i = 0;
		 ArrayList<Integer> options = new ArrayList<Integer>();
		 while (s.find(0) != s.find((n * n)-1) && i < length*length) {

		      int room = randomArray[i];
		      
		      
		      
		      if (room%n == 0 && room == 0) { //west closed and north open, either open east or south
		    	  maze[room][0] = 0;
		    	  if (s.find(room) != s.find(room+1)) { //if there is NOT a path b/w room the room to east, add to options
		    		  options.add(2);
		    	  } if (s.find(room) != s.find(room+length)) { 
		    		  options.add(1);
		    	  }
		    	  int randomNum = random.nextInt(4);
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(1)) {
		    		maze[room][1] = 0; 
		    		maze[room+length][0] = 0;
		    		s.union(room, room + length);//
		    	  } else if (options.contains(2)) {
		    	     maze[room][2] = 0;
		    	     maze[room+1][3] = 0;
		    	     s.union(room, room + 1);
		    	  }
		      } else if ( room == n-1) { //east closed and north closed
		    	  if (s.find(room) != s.find(room-1)) {
		    		  options.add(3);
		    	  } if (s.find(room) != s.find(room+length)) { //
		    		  options.add(1);
		    	  }
		    	  int randomNum = random.nextInt(4);
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(1)) {
		    		maze[room][1] = 0; 
		    		maze[room+length][0] = 0; //
		    		s.union(room, room +length); //
		    	  } else if (options.contains(3)) {
		    		  maze[room][3] = 0;
		    		  maze[room-1][2] = 0;
			    	  s.union(room, room -1);
		    	  }
		      } else if (room < n) { //north is closed
		    	  int randomNum = random.nextInt(4);
		    	  if (s.find(room) != s.find(room+1)) {
		    		  options.add(2);
		    	  } if (s.find(room) != s.find(room+length)) { //
		    		  options.add(1);
		    	  } if (s.find(room) != s.find(room-1)) {
		    		  options.add(3);
		    	  }
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(2)) {
		    		maze[room][2] = 0; 
		    		maze[room+1][3] = 0;
		    		s.union(room, room + 1);
		    	  } else if (randomNum == 1 && options.contains(1)) {
		    		  maze[room][1] = 0;
		    		  maze[room+length][0] = 0; //
			    	  s.union(room, room + length);  //
		    	  } else if (options.contains(3)){
		    		  maze[room][3] = 0;
		    		  maze[room-1][2] = 0;
			    	  s.union(room, room -1);
		    	  }
		      }
		      else if (room%n == 0 && room == n*n- n) { //west closed and south closed
		    	  int randomNum = random.nextInt(4);
		    	  if (s.find(room) != s.find(room-length)) {  //
		    		  options.add(0);
		    	  } if (s.find(room) != s.find(room+1)) {
		    		  options.add(2);
		    	  }
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(2)) {
		    		maze[room][2] = 0; 
		    		maze[room+1][3] = 0;
		    		s.union(room, room + 1);
		    	  } else if ((randomNum == 1 || randomNum == 0) && options.contains(0)) {
		    	     maze[room][0] = 0;
		    	     maze[room-length][1] = 0; //
		    	     s.union(room, room - length);
		    	  } 
		      } else if (room%n == 0) {  //west must be closed
		    	  if (s.find(room) != s.find(room+1)) {
		    		  options.add(2);
		    	  } if (s.find(room) != s.find(room+length)) {
		    		  options.add(1);
		    	  } if (s.find(room) != s.find(room-length)) { 
		    		  options.add(0);
		    	  }
		    	  int randomNum = random.nextInt(4);
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(2)) {
		    		maze[room][2] = 0; 
		    		maze[room+1][3] = 0;
		    		s.union(room, room + 1);
		    	  } else if (randomNum == 1 && options.contains(1)) {
		    	     maze[room][1] = 0;
		    	     maze[room+length][0] = 0;
		    	     s.union(room, room + length);
		    	  } else if (options.contains(0)){
		    		  maze[room][0] = 0;
		    		  maze[room-length][1] = 0;
			    	  s.union(room, room - length);
		    	  }
		      }  else if (room == n*n-1) { //east closed, south must be open
		    	  if (s.find(room) != s.find(room-1)) {
		    		  options.add(3);
		    	  } if (s.find(room) != s.find(room-length)) {
		    		  options.add(0);
		    	  }
		    	  maze[room][1] = 0;
		    	  int randomNum = random.nextInt(4);
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(3)) {
		    		maze[room][3] = 0; 
		    		maze[room-1][2] = 0;
		    		s.union(room, room - 1);
		    	  } else if (options.contains(0)) {
		    	     maze[room][0] = 0;
		    	     maze[room-length][1] = 0;
		    	     s.union(room, room - length);
		    	  }  
		      } else if (room > n*n-n-1 && room%n == 0) { //south and west must be closed
		    	  if (s.find(room) != s.find(room+1)) {
		    		  options.add(2);
		    	  } if (s.find(room) != s.find(room-length)) {
		    		  options.add(0);
		    	  }
		    	  int randomNum = random.nextInt(4);
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(2)) {
		    		maze[room][2] = 0; 
		    		maze[room+1][3] = 0;
		    		s.union(room, room + 1);
		    	  } else if (options.contains(0)) {
		    	     maze[room][0] = 0;
		    	     maze[room-length][1] = 0;
		    	     s.union(room, room - length);
		    	  }  
		      } else if (room > n*n-n-1) { //can't go south
		    	  if (s.find(room) != s.find(room+1)) {
		    		  options.add(2);
		    	  }  if (s.find(room) != s.find(room-length)) {
		    		  options.add(0);
		    	  }  if (s.find(room) != s.find(room-1)) {
		    		  options.add(3);
		    	  }
		    	  int randomNum = random.nextInt(4);
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(2)) {
		    		maze[room][2] = 0; 
		    		maze[room+1][3] = 0;
		    		s.union(room, room + 1);
		    	  } else if ((randomNum == 1 || randomNum == 0) && options.contains(0)) {
		    	     maze[room][0] = 0;
		    	     maze[room-length][1] = 0;
		    	     s.union(room, room - length);
		    	  } else if (options.contains(3)) {
		    		  maze[room][3] = 0;
		    		  maze[room-1][2] = 0;
			    	  s.union(room, room - 1);
		    	  }
		      } else if (room % n == n -1) { //east must be closed
		    	  if (s.find(room) != s.find(room-1)) {
		    		  options.add(3);
		    	  } if (s.find(room) != s.find(room-length)) {
		    		  options.add(0);
		    	  } if (s.find(room) != s.find(room +length)) {
		    		  options.add(1);
		    	  }
		    	  int randomNum = random.nextInt(4);
		    	  if ((randomNum == 2 || randomNum == 3) && options.contains(3)) {
		    		maze[room][3] = 0; 
		    		maze[room-1][2] = 0;
		    		s.union(room, room - 1);
		    	  } else if (randomNum == 0 && options.contains(0)) {
		    	     maze[room][0] = 0;
		    	     maze[room-length][1] = 0;
		    	     s.union(room, room -length);
		    	  }  else if (options.contains(1)){
		    		  maze[room][1] = 0;
		    		  maze[room+length][0] = 0;
			    	  s.union(room, room + length);
		    	  }
		      } else { //if the room is in the maze and can go in any direction
		    	  if (s.find(room) != s.find(room+1)) { 
		    		  options.add(2);
		    	  } if (s.find(room) != s.find(room+length)) {
		    		  options.add(1);
		    	  } 
		    	  if (s.find(room) != s.find(room-1)) {
		    		  options.add(3);
		    	  } if (s.find(room) != s.find(room-length)) {
		    		  options.add(0);
		    	  } 
		    	  int randomNum = random.nextInt(4);
		    	  if (randomNum == 2 && options.contains(2)) {
		    		maze[room][2] = 0; 
		    		maze[room+1][3] = 0;
		    		s.union(room, room + 1);
		    	  } else if (randomNum == 0 && options.contains(0)) {
		    	     maze[room][0] = 0;
		    	     maze[room-length][1] = 0;
		    	     s.union(room, room - length);
		    	  }  else if (randomNum == 1 && options.contains(1)){
		    		  maze[room][1] = 0;
		    		  maze[room+length][0] = 0;
			    	  s.union(room, room + length);
		    	  } else if (options.contains(3)) {
		    		  maze[room][3] = 0;
		    		  maze[room-1][2] = 0;
			    	  s.union(room, room -1);
		    	  }
		      }
		      i++;
		      options.clear();
		      if (i == length*length) {
		    	  i =0;
		      }
		 
	  }
		 System.out.println("");
		     
	}

	public static int[] shuffleArray(int[] walls)
	{
	  int[] newArray = walls;
	  Random rnd = ThreadLocalRandom.current();
	  for (int i = newArray.length - 1; i > 0; i--)
	  {
		  int index = rnd.nextInt(i + 1);
    
		  int a = newArray[index];
		  newArray[index] = newArray[i];
		  newArray[i] = a;
	  	}
	  return newArray;
	}
	
	
	public static void main(String[] args) {
		Maze3 mazes = new Maze3(5);
	}
	
